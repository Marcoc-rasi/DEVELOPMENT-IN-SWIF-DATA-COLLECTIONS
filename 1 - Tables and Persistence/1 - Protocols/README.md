# Protocols

In this lesson, I learned how to use Swift protocols to provide common method definitions across multiple objects, as well as adopt the delegation pattern widely used in iOS. I have understood how to define, adopt, and enforce Swift protocols to provide a common set of functionality across multiple classes.

## What I Learned

- Describe the purpose of `protocols`
- Describe three included Swift protocols (`CustomStringConvertible`, `Equatable`, `Comparable`)
- Demonstrate how to adopt a protocol
- Demonstrate how to define a protocol
- Describe and implement the delegate pattern using `protocols`
- Demonstrate how to conform to a protocol with an extension
- Demonstrate how to add a default implementation to a protocol function

## Vocabulary
- `adopt`: Accept and apply a protocol.
- `Codable`: A Swift protocol indicating that a type can be encoded and decoded.
- `Comparable`: A protocol that allows comparing instances of a type to determine their relative order.
- `conform to`: Satisfy the requirements of a protocol.
- `CustomStringConvertible`: A protocol allowing the custom representation of an object as a string.
- `delegate`: An object that performs tasks on behalf of another object.
- `Equatable`: A protocol that requires the implementation of the `==` method to compare the equality of two instances.
- `implementation`: The practical realization of a protocol in a type.
- `protocol`: A set of rules that defines how a type should behave.
- `read-only`: Property that can only be read.
- `read/write`: Property that can be read and modified.
